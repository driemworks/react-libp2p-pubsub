import os from 'os';
import { TypedEventEmitter } from '@libp2p/interface';
import { ipPortToMultiaddr as toMultiaddr } from '@libp2p/utils/ip-port-to-multiaddr';
import { multiaddr, protocols } from '@multiformats/multiaddr';
import { createServer } from 'it-ws/server';
import { socketToMaConn } from './socket-to-conn.js';
class WebSocketListener extends TypedEventEmitter {
    connections;
    listeningMultiaddr;
    server;
    log;
    metrics;
    addr;
    constructor(components, init) {
        super();
        this.log = components.logger.forComponent('libp2p:websockets:listener');
        const metrics = components.metrics;
        // Keep track of open connections to destroy when the listener is closed
        this.connections = new Set();
        const self = this; // eslint-disable-line @typescript-eslint/no-this-alias
        this.addr = 'unknown';
        this.server = createServer({
            ...init,
            onConnection: (stream) => {
                const maConn = socketToMaConn(stream, toMultiaddr(stream.remoteAddress ?? '', stream.remotePort ?? 0), {
                    logger: components.logger,
                    metrics: this.metrics?.events,
                    metricPrefix: `${this.addr} `
                });
                this.log('new inbound connection %s', maConn.remoteAddr);
                this.connections.add(stream);
                stream.socket.on('close', function () {
                    self.connections.delete(stream);
                });
                try {
                    void init.upgrader.upgradeInbound(maConn)
                        .then((conn) => {
                        this.log('inbound connection %s upgraded', maConn.remoteAddr);
                        if (init?.handler != null) {
                            init?.handler(conn);
                        }
                        self.dispatchEvent(new CustomEvent('connection', {
                            detail: conn
                        }));
                    })
                        .catch(async (err) => {
                        this.log.error('inbound connection failed to upgrade', err);
                        this.metrics?.errors.increment({ [`${this.addr} inbound_upgrade`]: true });
                        await maConn.close().catch(err => {
                            this.log.error('inbound connection failed to close after upgrade failed', err);
                        });
                    });
                }
                catch (err) {
                    this.log.error('inbound connection failed to upgrade', err);
                    maConn.close().catch(err => {
                        this.log.error('inbound connection failed to close after upgrade failed', err);
                        this.metrics?.errors.increment({ [`${this.addr} inbound_closing_failed`]: true });
                    });
                }
            }
        });
        this.server.on('listening', () => {
            if (metrics != null) {
                const { host, port } = this.listeningMultiaddr?.toOptions() ?? {};
                this.addr = `${host}:${port}`;
                metrics.registerMetricGroup('libp2p_websockets_inbound_connections_total', {
                    label: 'address',
                    help: 'Current active connections in WebSocket listener',
                    calculate: () => {
                        return {
                            [this.addr]: this.connections.size
                        };
                    }
                });
                this.metrics = {
                    status: metrics?.registerMetricGroup('libp2p_websockets_listener_status_info', {
                        label: 'address',
                        help: 'Current status of the WebSocket listener socket'
                    }),
                    errors: metrics?.registerMetricGroup('libp2p_websockets_listener_errors_total', {
                        label: 'address',
                        help: 'Total count of WebSocket listener errors by type'
                    }),
                    events: metrics?.registerMetricGroup('libp2p_websockets_listener_events_total', {
                        label: 'address',
                        help: 'Total count of WebSocket listener events by type'
                    })
                };
            }
            this.dispatchEvent(new CustomEvent('listening'));
        });
        this.server.on('error', (err) => {
            this.metrics?.errors.increment({ [`${this.addr} listen_error`]: true });
            this.dispatchEvent(new CustomEvent('error', {
                detail: err
            }));
        });
        this.server.on('close', () => {
            this.dispatchEvent(new CustomEvent('close'));
        });
    }
    async close() {
        await Promise.all(Array.from(this.connections).map(async (maConn) => { await maConn.close(); }));
        if (this.server.address() == null) {
            // not listening, close will throw an error
            return;
        }
        await this.server.close();
    }
    async listen(ma) {
        this.listeningMultiaddr = ma;
        await this.server.listen(ma.toOptions());
    }
    getAddrs() {
        const multiaddrs = [];
        const address = this.server.address();
        if (address == null) {
            throw new Error('Listener is not ready yet');
        }
        if (typeof address === 'string') {
            throw new Error('Wrong address type received - expected AddressInfo, got string - are you trying to listen on a unix socket?');
        }
        if (this.listeningMultiaddr == null) {
            throw new Error('Listener is not ready yet');
        }
        const ipfsId = this.listeningMultiaddr.getPeerId();
        const protos = this.listeningMultiaddr.protos();
        // Because TCP will only return the IPv6 version
        // we need to capture from the passed multiaddr
        if (protos.some(proto => proto.code === protocols('ip4').code)) {
            const wsProto = protos.some(proto => proto.code === protocols('ws').code) ? '/ws' : '/wss';
            let m = this.listeningMultiaddr.decapsulate('tcp');
            m = m.encapsulate(`/tcp/${address.port}${wsProto}`);
            if (ipfsId != null) {
                m = m.encapsulate(`/p2p/${ipfsId}`);
            }
            if (m.toString().includes('0.0.0.0')) {
                const netInterfaces = os.networkInterfaces();
                Object.values(netInterfaces).forEach(niInfos => {
                    if (niInfos == null) {
                        return;
                    }
                    niInfos.forEach(ni => {
                        if (ni.family === 'IPv4') {
                            multiaddrs.push(multiaddr(m.toString().replace('0.0.0.0', ni.address)));
                        }
                    });
                });
            }
            else {
                multiaddrs.push(m);
            }
        }
        return multiaddrs;
    }
}
export function createListener(components, init) {
    return new WebSocketListener(components, init);
}
//# sourceMappingURL=listener.js.map