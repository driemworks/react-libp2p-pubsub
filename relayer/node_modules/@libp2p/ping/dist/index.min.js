(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PPing = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PPing=(()=>{var A=Object.defineProperty;var q=Object.getOwnPropertyDescriptor;var H=Object.getOwnPropertyNames;var K=Object.prototype.hasOwnProperty;var Y=(n,t)=>{for(var e in t)A(n,e,{get:t[e],enumerable:!0})},J=(n,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of H(t))!K.call(n,o)&&o!==e&&A(n,o,{get:()=>t[o],enumerable:!(r=q(t,o))||r.enumerable});return n};var Q=n=>J(A({},"__esModule",{value:!0}),n);var lt={};Y(lt,{PING_PROTOCOL:()=>G,ping:()=>at});var l=class extends Error{code;props;constructor(t,e,r){super(t),this.code=e,this.name=r?.name??"CodeError",this.props=r??{}}};var T="ERR_TIMEOUT";var M="ERR_INVALID_MESSAGE";function C(n,t){if(n===t)return!0;if(n.byteLength!==t.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n[e]!==t[e])return!1;return!0}var g=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var gt=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;var bt={}.toString;function v(n=32){if(g&&typeof g.getRandomValues=="function")return g.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function b(n){if(isNaN(n)||n<=0)throw new l("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return v(n)}function Z(n){return n[Symbol.asyncIterator]!=null}function tt(n){if(Z(n))return(async()=>{for await(let t of n)return t})();for(let t of n)return t}var U=tt;function x(){let n={};return n.promise=new Promise((t,e)=>{n.resolve=t,n.reject=e}),n}var E=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},m=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new E(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new E(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var I=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function w(n={}){return et(e=>{let r=e.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function et(n,t){t=t??{};let e=t.onEnd,r=new m,o,i,u,c=x(),a=async()=>{try{return r.isEmpty()?u?{done:!0}:await new Promise((s,p)=>{i=y=>{i=null,r.push(y);try{s(n(r))}catch(d){p(d)}return o}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{c.resolve(),c=x()})}},f=s=>i!=null?i(s):(r.push(s),o),O=s=>(r=new m,i!=null?i({error:s}):(r.push({error:s}),o)),P=s=>{if(u)return o;if(t?.objectMode!==!0&&s?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return f({done:!1,value:s})},R=s=>u?o:(u=!0,s!=null?O(s):f({done:!0})),F=()=>(r=new m,R(),{done:!0}),W=s=>(R(s),{done:!0});if(o={[Symbol.asyncIterator](){return this},next:a,return:F,throw:W,push:P,end:R,get readableLength(){return r.size},onEmpty:async s=>{let p=s?.signal;if(p?.throwIfAborted(),r.isEmpty())return;let y,d;p!=null&&(y=new Promise((ft,$)=>{d=()=>{$(new I)},p.addEventListener("abort",d)}));try{await Promise.race([c.promise,y])}finally{d!=null&&p!=null&&p?.removeEventListener("abort",d)}}},e==null)return o;let h=o;return o={[Symbol.asyncIterator](){return this},next(){return h.next()},throw(s){return h.throw(s),e!=null&&(e(s),e=void 0),{done:!0}},return(){return h.return(),e!=null&&(e(),e=void 0),{done:!0}},push:P,end(s){return h.end(s),e!=null&&(e(s),e=void 0),o},get readableLength(){return h.readableLength},onEmpty:s=>h.onEmpty(s)},o}function nt(n){return n[Symbol.asyncIterator]!=null}function rt(...n){let t=[];for(let e of n)nt(e)||t.push(e);return t.length===n.length?function*(){for(let e of t)yield*e}():async function*(){let e=w({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(n.map(async r=>{for await(let o of r)e.push(o)})),e.end()}catch(r){e.end(r)}}),yield*e}()}var D=rt;function L(n,...t){if(n==null)throw new Error("Empty pipeline");if(S(n)){let r=n;n=()=>r.source}else if(B(n)||k(n)){let r=n;n=()=>r}let e=[n,...t];if(e.length>1&&S(e[e.length-1])&&(e[e.length-1]=e[e.length-1].sink),e.length>2)for(let r=1;r<e.length-1;r++)S(e[r])&&(e[r]=st(e[r]));return ot(...e)}var ot=(...n)=>{let t;for(;n.length>0;)t=n.shift()(t);return t},k=n=>n?.[Symbol.asyncIterator]!=null,B=n=>n?.[Symbol.iterator]!=null,S=n=>n==null?!1:n.sink!=null&&n.source!=null,st=n=>t=>{let e=n.sink(t);if(e?.then!=null){let r=w({objectMode:!0});e.then(()=>{r.end()},u=>{r.end(u)});let o,i=n.source;if(k(i))o=async function*(){yield*i,r.end()};else if(B(i))o=function*(){yield*i,r.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return D(r,o())}return n.source};var G="/ipfs/ping/1.0.0";var V="1.0.0",z="ping",X="ipfs";var N="ERR_WRONG_PING_ACK";var _=class{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnTransientConnection;log;constructor(t,e={}){this.components=t,this.log=t.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${e.protocolPrefix??X}/${z}/${V}`,this.timeout=e.timeout??1e4,this.maxInboundStreams=e.maxInboundStreams??2,this.maxOutboundStreams=e.maxOutboundStreams??1,this.runOnTransientConnection=e.runOnTransientConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnTransientConnection:this.runOnTransientConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(t){this.log("incoming ping from %p",t.connection.remotePeer);let{stream:e}=t,r=Date.now();AbortSignal.timeout(this.timeout).addEventListener("abort",()=>{e?.abort(new l("ping timeout",T))}),L(e,async function*(i){let u=0;for await(let c of i){if(u+=c.byteLength,u>32){e?.abort(new l("Too much data received",M));return}yield c}},e).catch(i=>{this.log.error("incoming ping from %p failed with error",t.connection.remotePeer,i),e?.abort(i)}).finally(()=>{let i=Date.now()-r;this.log("incoming ping from %p complete in %dms",t.connection.remotePeer,i)})}async ping(t,e={}){this.log("pinging %p",t);let r=Date.now(),o=b(32),i=await this.components.connectionManager.openConnection(t,e),u,c=()=>{};if(e.signal==null){let a=AbortSignal.timeout(this.timeout);e={...e,signal:a}}try{u=await i.newStream(this.protocol,{...e,runOnTransientConnection:this.runOnTransientConnection}),c=()=>{u?.abort(new l("ping timeout",T))},e.signal?.addEventListener("abort",c,{once:!0});let a=await L([o],u,async O=>U(O)),f=Date.now()-r;if(a==null)throw new l(`Did not receive a ping ack after ${f}ms`,N);if(!C(o,a.subarray()))throw new l(`Received wrong ping ack after ${f}ms`,N);return this.log("ping %p complete in %dms",i.remotePeer,f),f}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),u?.abort(a),a}finally{e.signal?.removeEventListener("abort",c),u!=null&&await u.close()}}};function at(n={}){return t=>new _(t,n)}return Q(lt);})();
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
return Libp2PPing}));
