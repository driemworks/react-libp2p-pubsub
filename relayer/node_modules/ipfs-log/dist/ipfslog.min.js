var Log;(()=>{var e={136:e=>{e.exports={space:"",cycles:!1,replacer:(e,t)=>t,stringify:JSON.stringify}},299:(e,t,r)=>{"use strict";const n=r(136),o=r(572).isFunction,i=r(572).isBoolean,s=r(572).isObject,a=r(572).isArray,c=r(572).isRegex,u=r(572).assign,h=r(572).keys;e.exports=function(e,t){t=t||u({},n),o(t)&&(t={compare:t});const r=t.space||n.space,l=i(t.cycles)?t.cycles:n.cycles,f=t.replacer||n.replacer,d=t.stringify||n.stringify,y=t.compare&&(p=t.compare,function(e){return function(t,r){const n={key:t,value:e[t]},o={key:r,value:e[r]};return p(n,o)}});var p;l||d(e);const w=[];return function e(t,n,o,i){const u=r?"\n"+new Array(i+1).join(r):"",p=r?": ":":";if(o=function(e){return null==e?e:c(e)?e.toString():e.toJSON?e.toJSON():e}(o),void 0!==(o=f.call(t,n,o))){if(!s(o)||null===o)return d(o);if(a(o)){const t=[];for(let n=0;n<o.length;n++){const s=e(o,n,o[n],i+1)||d(null);t.push(u+r+s)}return"["+t.join(",")+u+"]"}{if(l){if(-1!==w.indexOf(o))return d("[Circular]");w.push(o)}const t=h(o).sort(y&&y(o)),n=[];for(let s=0;s<t.length;s++){const a=t[s],c=e(o,a,o[a],i+1);if(!c)continue;const h=d(a)+p+c;n.push(u+r+h)}return w.splice(w.indexOf(o),1),"{"+n.join(",")+u+"}"}}}({"":e},"",e,0)}},572:e=>{"use strict";e.exports={isArray:Array.isArray,assign:Object.assign,isObject:e=>"object"==typeof e,isFunction:e=>"function"==typeof e,isBoolean:e=>"boolean"==typeof e,isRegex:e=>e instanceof RegExp,keys:Object.keys}},696:()=>{}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{"use strict";r.r(n),r.d(n,{AccessController:()=>Zr,Entry:()=>Nr,IPLD_LINKS:()=>xr,Sorting:()=>Ur,default:()=>cn,getWriteFormat:()=>Ir});var e={};r.r(e),r.d(e,{code:()=>$e,createLink:()=>Se,createNode:()=>Be,decode:()=>Oe,encode:()=>Pe,name:()=>De,prepare:()=>Ce,validate:()=>je});var t={};r.r(t),r.d(t,{code:()=>ar,decode:()=>ur,encode:()=>cr,name:()=>sr});var o=r(696);const i=/\s+at.*[(\s](.*)\)?/,s=/^(?:(?:(?:node|node:[\w/]+|(?:(?:node:)?internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)(?:\.js)?:\d+:\d+)|native)/,a=void 0===o.homedir?"":o.homedir().replace(/\\/g,"/");class c extends Error{#e;name="AggregateError";constructor(e){if(!Array.isArray(e))throw new TypeError("Expected input to be an Array, got "+typeof e);let t=(e=e.map((e=>e instanceof Error?e:null!==e&&"object"==typeof e?Object.assign(new Error(e.message),e):new Error(e)))).map((e=>"string"==typeof e.stack&&e.stack.length>0?function(e,{pretty:t=!1,basePath:r}={}){const n=r&&new RegExp(`(at | \\()${function(e){if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}(r.replace(/\\/g,"/"))}`,"g");if("string"==typeof e)return e.replace(/\\/g,"/").split("\n").filter((e=>{const t=e.match(i);if(null===t||!t[1])return!0;const r=t[1];return!(r.includes(".app/Contents/Resources/electron.asar")||r.includes(".app/Contents/Resources/default_app.asar")||r.includes("node_modules/electron/dist/resources/electron.asar")||r.includes("node_modules/electron/dist/resources/default_app.asar")||s.test(r))})).filter((e=>""!==e.trim())).map((e=>(n&&(e=e.replace(n,"$1")),t&&(e=e.replace(i,((e,t)=>e.replace(t,t.replace(a,"~"))))),e))).join("\n")}(e.stack).replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g,""):String(e))).join("\n");t="\n"+function(e,t=1,r={}){const{indent:n=" ",includeEmptyLines:o=!1}=r;if("string"!=typeof e)throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if("number"!=typeof t)throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(t<0)throw new RangeError(`Expected \`count\` to be at least 0, got \`${t}\``);if("string"!=typeof n)throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof n}\``);if(0===t)return e;const i=o?/^/gm:/^(?!\s*$)/gm;return e.replace(i,n.repeat(t))}(t,4),super(t),this.#e=e}get errors(){return this.#e.slice()}}class u extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const h=e=>void 0===globalThis.DOMException?new u(e):new DOMException(e),l=e=>{const t=void 0===e.reason?h("This operation was aborted."):e.reason;return t instanceof Error?t:h(t)};async function f(e,t,{concurrency:r=Number.POSITIVE_INFINITY,stopOnError:n=!0,signal:o}={}){return new Promise(((i,s)=>{if(void 0===e[Symbol.iterator]&&void 0===e[Symbol.asyncIterator])throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`);if("function"!=typeof t)throw new TypeError("Mapper function is required");if(!Number.isSafeInteger(r)&&r!==Number.POSITIVE_INFINITY||!(r>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);const a=[],u=[],h=new Map;let f=!1,y=!1,p=!1,w=0,g=0;const b=void 0===e[Symbol.iterator]?e[Symbol.asyncIterator]():e[Symbol.iterator](),m=e=>{f=!0,y=!0,s(e)};o&&(o.aborted&&m(l(o)),o.addEventListener("abort",(()=>{m(l(o))})));const v=async()=>{if(y)return;const e=await b.next(),r=g;if(g++,e.done){if(p=!0,0===w&&!y){if(!n&&u.length>0)return void m(new c(u));if(y=!0,0===h.size)return void i(a);const e=[];for(const[t,r]of a.entries())h.get(t)!==d&&e.push(r);i(e)}}else w++,(async()=>{try{const n=await e.value;if(y)return;const o=await t(n,r);o===d&&h.set(r,o),a[r]=o,w--,await v()}catch(e){if(n)m(e);else{u.push(e),w--;try{await v()}catch(e){m(e)}}}})()};(async()=>{for(let e=0;e<r;e++){try{await v()}catch(e){m(e);break}if(p||f)break}})()}))}const d=Symbol("skip"),y=class{constructor(e){}append(e){}merge(e){}get(e){}has(e){}get values(){}get length(){}};class p{constructor(e,t){this.id=e,this.time=t||0}tick(){return new p(this.id,++this.time)}merge(e){return this.time=Math.max(this.time,e.time),new p(this.id,this.time)}clone(){return new p(this.id,this.time)}static compare(e,t){const r=e.time-t.time;return 0===r&&e.id!==t.id?e.id<t.id?-1:1:r}}const w=p;var g=Math.pow(2,31),b=Math.pow(2,7),m=Math.pow(2,14),v=Math.pow(2,21),E=Math.pow(2,28),k=Math.pow(2,35),x=Math.pow(2,42),A=Math.pow(2,49),I=Math.pow(2,56),T=Math.pow(2,63);const N={encode:function e(t,r,n){r=r||[];for(var o=n=n||0;t>=g;)r[n++]=255&t|128,t/=128;for(;-128&t;)r[n++]=255&t|128,t>>>=7;return r[n]=0|t,e.bytes=n-o+1,r},decode:function e(t,r){var n,o=0,i=0,s=r=r||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");n=t[s++],o+=i<28?(127&n)<<i:(127&n)*Math.pow(2,i),i+=7}while(n>=128);return e.bytes=s-r,o},encodingLength:function(e){return e<b?1:e<m?2:e<v?3:e<E?4:e<k?5:e<x?6:e<A?7:e<I?8:e<T?9:10}},C=(e,t=0)=>[N.decode(e,t),N.decode.bytes],j=(e,t,r=0)=>(N.encode(e,t,r),t),B=e=>N.encodingLength(e),S=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}),D=(e,t)=>{const r=t.byteLength,n=B(e),o=n+B(r),i=new Uint8Array(o+r);return j(e,i,0),j(r,i,n),i.set(t,o),new $(e,r,t,i)};class ${constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}const P=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),s=i.charCodeAt(0);if(255!==r[s])throw new TypeError(i+" is ambiguous");r[s]=o}var a=e.length,c=e.charAt(0),u=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function l(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,o=0;e[t]===c;)n++,t++;for(var i=(e.length-t)*u+1>>>0,s=new Uint8Array(i);e[t];){var h=r[e.charCodeAt(t)];if(255===h)return;for(var l=0,f=i-1;(0!==h||l<o)&&-1!==f;f--,l++)h+=a*s[f]>>>0,s[f]=h%256>>>0,h=h/256>>>0;if(0!==h)throw new Error("Non-zero carry");o=l,t++}if(" "!==e[t]){for(var d=i-o;d!==i&&0===s[d];)d++;for(var y=new Uint8Array(n+(i-d)),p=n;d!==i;)y[p++]=s[d++];return y}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,o=0,i=t.length;o!==i&&0===t[o];)o++,r++;for(var s=(i-o)*h+1>>>0,u=new Uint8Array(s);o!==i;){for(var l=t[o],f=0,d=s-1;(0!==l||f<n)&&-1!==d;d--,f++)l+=256*u[d]>>>0,u[d]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=f,o++}for(var y=s-n;y!==s&&0===u[y];)y++;for(var p=c.repeat(r);y<s;++y)p+=e.charAt(u[y]);return p},decodeUnsafe:l,decode:function(e){var r=l(e);if(r)return r;throw new Error(`Non-${t} character`)}}};class O{constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class U{constructor(e,t,r){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return L(this,e)}}class _{constructor(e){this.decoders=e}or(e){return L(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const L=(e,t)=>new _({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class M{constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new O(e,t,r),this.decoder=new U(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const z=({name:e,prefix:t,encode:r,decode:n})=>new M(e,t,r,n),H=({prefix:e,name:t,alphabet:r})=>{const{encode:n,decode:o}=P(r,t);return z({prefix:e,name:t,encode:n,decode:e=>S(o(e))})},F=({name:e,prefix:t,bitsPerChar:r,alphabet:n})=>z({prefix:t,name:e,encode:e=>((e,t,r)=>{const n="="===t[t.length-1],o=(1<<r)-1;let i="",s=0,a=0;for(let n=0;n<e.length;++n)for(a=a<<8|e[n],s+=8;s>r;)s-=r,i+=t[o&a>>s];if(s&&(i+=t[o&a<<r-s]),n)for(;i.length*r&7;)i+="=";return i})(e,n,r),decode:t=>((e,t,r,n)=>{const o={};for(let e=0;e<t.length;++e)o[t[e]]=e;let i=e.length;for(;"="===e[i-1];)--i;const s=new Uint8Array(i*r/8|0);let a=0,c=0,u=0;for(let t=0;t<i;++t){const i=o[e[t]];if(void 0===i)throw new SyntaxError(`Non-${n} character`);c=c<<r|i,a+=r,a>=8&&(a-=8,s[u++]=255&c>>a)}if(a>=r||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(t,n,r,e)}),G=H({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),R=(H({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),F({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5})),V=(F({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),F({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),F({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),F({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),F({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),F({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),F({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),F({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),(e,t)=>{const{bytes:r,version:n}=e;return 0===n?Q(r,J(e),t||G.encoder):Z(r,J(e),t||R.encoder)}),q=new WeakMap,J=e=>{const t=q.get(e);if(null==t){const t=new Map;return q.set(e,t),t}return t};class W{constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Y)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==X)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return W.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=D(e,t);return W.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return W.equals(this,e)}static equals(e,t){const r=t;return r&&e.code===r.code&&e.version===r.version&&((e,t)=>{if(e===t)return!0;{const r=t;return e.code===r.code&&e.size===r.size&&r.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0})(e.bytes,r.bytes)}})(e.multihash,r.multihash)}toString(e){return V(this,e)}toJSON(){return{"/":V(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(null==e)return null;const t=e;if(t instanceof W)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:r,multihash:n,bytes:o}=t;return new W(e,r,n,o||ee(e,r,n.bytes))}if(!0===t[te]){const{version:e,multihash:r,code:n}=t,o=(e=>{const t=S(e),[r,n]=C(t),[o,i]=C(t.subarray(n)),s=t.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new $(r,o,s,t)})(r);return W.create(e,n,o)}return null}static create(e,t,r){if("number"!=typeof t)throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==Y)throw new Error(`Version 0 CID must use dag-pb (code: ${Y}) block encoding`);return new W(e,t,r,r.bytes);case 1:{const n=ee(e,t,r.bytes);return new W(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return W.create(0,Y,e)}static createV1(e,t){return W.create(1,e,t)}static decode(e){const[t,r]=W.decodeFirst(e);if(r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=W.inspectBytes(e),r=t.size-t.multihashSize,n=S(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const o=n.subarray(t.multihashSize-t.digestSize),i=new $(t.multihashCode,t.digestSize,o,n);return[0===t.version?W.createV0(i):W.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=C(e.subarray(t));return t+=n,r};let n=r(),o=Y;if(18===n?(n=0,t=0):o=r(),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const i=t,s=r(),a=r(),c=t+a;return{version:n,codec:o,multihashCode:s,digestSize:a,multihashSize:c-i,size:c}}static parse(e,t){const[r,n]=K(e,t),o=W.decode(n);if(0===o.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return J(o).set(r,e),o}}const K=(e,t)=>{switch(e[0]){case"Q":{const r=t||G;return[G.prefix,r.decode(`${G.prefix}${e}`)]}case G.prefix:{const r=t||G;return[G.prefix,r.decode(e)]}case R.prefix:{const r=t||R;return[R.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},Q=(e,t,r)=>{const{prefix:n}=r;if(n!==G.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=t.get(n);if(null==o){const o=r.encode(e).slice(1);return t.set(n,o),o}return o},Z=(e,t,r)=>{const{prefix:n}=r,o=t.get(n);if(null==o){const o=r.encode(e);return t.set(n,o),o}return o},Y=112,X=18,ee=(e,t,r)=>{const n=B(e),o=n+B(t),i=new Uint8Array(o+r.byteLength);return j(e,i,0),j(t,i,n),i.set(r,o),i},te=Symbol.for("@ipld/js-cid/CID"),re=({name:e,code:t,encode:r})=>new ne(e,t,r);class ne{constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?D(this.code,t):t.then((e=>D(this.code,e)))}throw Error("Unknown type, must be binary type")}}function oe({enumerable:e=!0,configurable:t=!1}={}){return{enumerable:e,configurable:t,writable:!1}}function*ie(e,t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))for(const[r,n]of t.entries()){const t=[...e,r],o=W.asCID(n);o?yield[t.join("/"),o]:"object"==typeof n&&(yield*se(n,t))}else{const r=W.asCID(t);r?yield[e.join("/"),r]:yield*se(t,e)}}function*se(e,t){if(null==e||e instanceof Uint8Array)return;const r=W.asCID(e);r&&(yield[t.join("/"),r]);for(const[r,n]of Object.entries(e)){const e=[...t,r];yield*ie(e,n)}}function*ae(e,t){if(Array.isArray(t))for(const[r,n]of t.entries()){const t=[...e,r];yield t.join("/"),"object"!=typeof n||W.asCID(n)||(yield*ce(n,t))}else yield*ce(t,e)}function*ce(e,t){if(null!=e&&"object"==typeof e)for(const[r,n]of Object.entries(e)){const e=[...t,r];yield e.join("/"),null==n||n instanceof Uint8Array||"object"!=typeof n||W.asCID(n)||(yield*ae(e,n))}}class ue{constructor({cid:e,bytes:t,value:r}){if(!e||!t||void 0===r)throw new Error("Missing required argument");this.cid=e,this.bytes=t,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:oe(),bytes:oe(),value:oe(),asBlock:oe()})}links(){return se(this.value,[])}tree(){return ce(this.value,[])}get(e="/"){return function(e,t){let r=e;for(const[e,n]of t.entries()){if(r=r[n],null==r)throw new Error(`Object has no property at ${t.slice(0,e+1).map((e=>`[${JSON.stringify(e)}]`)).join("")}`);const o=W.asCID(r);if(o)return{value:o,remaining:t.slice(e+1).join("/")}}return{value:r}}(this.value,e.split("/").filter(Boolean))}}const he=new TextDecoder;function le(e,t){let r=0;for(let n=0;;n+=7){if(n>=64)throw new Error("protobuf: varint overflow");if(t>=e.length)throw new Error("protobuf: unexpected end of data");const o=e[t++];if(r+=n<28?(127&o)<<n:(127&o)*2**n,o<128)break}return[r,t]}function fe(e,t){let r;[r,t]=le(e,t);const n=t+r;if(r<0||n<0)throw new Error("protobuf: invalid length");if(n>e.length)throw new Error("protobuf: unexpected end of data");return[e.subarray(t,n),n]}function de(e,t){let r;return[r,t]=le(e,t),[7&r,r>>3,t]}function ye(e){const t={},r=e.length;let n=0;for(;n<r;){let r,o;if([r,o,n]=de(e,n),1===o){if(t.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(2!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Hash`);if(void 0!==t.Name)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[t.Hash,n]=fe(e,n)}else if(2===o){if(void 0!==t.Name)throw new Error("protobuf: (PBLink) duplicate Name section");if(2!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Name`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let o;[o,n]=fe(e,n),t.Name=he.decode(o)}else{if(3!==o)throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${o}`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(0!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Tsize`);[t.Tsize,n]=le(e,n)}}if(n>r)throw new Error("protobuf: (PBLink) unexpected end of data");return t}const pe=new TextEncoder,we=2**32;function ge(e,t){let r=t.length;if("number"==typeof e.Tsize){if(e.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(e.Tsize))throw new Error("Tsize too large for encoding");r=me(t,r,e.Tsize)-1,t[r]=24}if("string"==typeof e.Name){const n=pe.encode(e.Name);r-=n.length,t.set(n,r),r=me(t,r,n.length)-1,t[r]=18}return e.Hash&&(r-=e.Hash.length,t.set(e.Hash,r),r=me(t,r,e.Hash.length)-1,t[r]=10),t.length-r}function be(e){let t=0;if(e.Hash){const r=e.Hash.length;t+=1+r+ve(r)}if("string"==typeof e.Name){const r=pe.encode(e.Name).length;t+=1+r+ve(r)}return"number"==typeof e.Tsize&&(t+=1+ve(e.Tsize)),t}function me(e,t,r){const n=t-=ve(r);for(;r>=2147483648;)e[t++]=127&r|128,r/=128;for(;r>=128;)e[t++]=127&r|128,r>>>=7;return e[t]=r,n}function ve(e){return e%2==0&&e++,Math.floor((function(e){let t=0;return e>=we&&(e=Math.floor(e/we),t=32),e>=65536&&(e>>>=16,t+=16),e>=256&&(e>>>=8,t+=8),t+Ee[e]}(e)+6)/7)}const Ee=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],ke=["Data","Links"],xe=["Hash","Name","Tsize"],Ae=new TextEncoder;function Ie(e,t){if(e===t)return 0;const r=e.Name?Ae.encode(e.Name):[],n=t.Name?Ae.encode(t.Name):[];let o=r.length,i=n.length;for(let e=0,t=Math.min(o,i);e<t;++e)if(r[e]!==n[e]){o=r[e],i=n[e];break}return o<i?-1:i<o?1:0}function Te(e,t){return!Object.keys(e).some((e=>!t.includes(e)))}function Ne(e){if("object"==typeof e.asCID){const t=W.asCID(e);if(!t)throw new TypeError("Invalid DAG-PB form");return{Hash:t}}if("object"!=typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(e.Hash){let r=W.asCID(e.Hash);try{r||("string"==typeof e.Hash?r=W.parse(e.Hash):e.Hash instanceof Uint8Array&&(r=W.decode(e.Hash)))}catch(e){throw new TypeError(`Invalid DAG-PB form: ${e.message}`)}r&&(t.Hash=r)}if(!t.Hash)throw new TypeError("Invalid DAG-PB form");return"string"==typeof e.Name&&(t.Name=e.Name),"number"==typeof e.Tsize&&(t.Tsize=e.Tsize),t}function Ce(e){if((e instanceof Uint8Array||"string"==typeof e)&&(e={Data:e}),"object"!=typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(void 0!==e.Data)if("string"==typeof e.Data)t.Data=Ae.encode(e.Data);else{if(!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form");t.Data=e.Data}if(void 0!==e.Links){if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form");t.Links=e.Links.map(Ne),t.Links.sort(Ie)}else t.Links=[];return t}function je(e){if(!e||"object"!=typeof e||Array.isArray(e)||e instanceof Uint8Array||e["/"]&&e["/"]===e.bytes)throw new TypeError("Invalid DAG-PB form");if(!Te(e,ke))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(void 0!==e.Data&&!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be bytes)");if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form (Links must be a list)");for(let t=0;t<e.Links.length;t++){const r=e.Links[t];if(!r||"object"!=typeof r||Array.isArray(r)||r instanceof Uint8Array||r["/"]&&r["/"]===r.bytes)throw new TypeError("Invalid DAG-PB form (bad link)");if(!Te(r,xe))throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");if(void 0===r.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(null==r.Hash||!r.Hash["/"]||r.Hash["/"]!==r.Hash.bytes)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(void 0!==r.Name&&"string"!=typeof r.Name)throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(void 0!==r.Tsize){if("number"!=typeof r.Tsize||r.Tsize%1!=0)throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(r.Tsize<0)throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)")}if(t>0&&-1===Ie(r,e.Links[t-1]))throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function Be(e,t=[]){return Ce({Data:e,Links:t})}function Se(e,t,r){return Ne({Hash:r,Name:e,Tsize:t})}const De="dag-pb",$e=112;function Pe(e){je(e);const t={};return e.Links&&(t.Links=e.Links.map((e=>{const t={};return e.Hash&&(t.Hash=e.Hash.bytes),void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),e.Data&&(t.Data=e.Data),function(e){const t=function(e){let t=0;if(e.Data){const r=e.Data.length;t+=1+r+ve(r)}if(e.Links)for(const r of e.Links){const e=be(r);t+=1+e+ve(e)}return t}(e),r=new Uint8Array(t);let n=t;if(e.Data&&(n-=e.Data.length,r.set(e.Data,n),n=me(r,n,e.Data.length)-1,r[n]=10),e.Links)for(let t=e.Links.length-1;t>=0;t--){const o=ge(e.Links[t],r.subarray(0,n));n-=o,n=me(r,n,o)-1,r[n]=18}return r}(t)}function Oe(e){const t=function(e){const t=e.length;let r,n,o=0,i=!1;for(;o<t;){let t,s;if([t,s,o]=de(e,o),2!==t)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${t}`);if(1===s){if(n)throw new Error("protobuf: (PBNode) duplicate Data section");[n,o]=fe(e,o),r&&(i=!0)}else{if(2!==s)throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${s}`);{if(i)throw new Error("protobuf: (PBNode) duplicate Links section");let t;r||(r=[]),[t,o]=fe(e,o),r.push(ye(t))}}}if(o>t)throw new Error("protobuf: (PBNode) unexpected end of data");const s={};return n&&(s.Data=n),s.Links=r||[],s}(e),r={};return t.Data&&(r.Data=t.Data),t.Links&&(r.Links=t.Links.map((e=>{const t={};try{t.Hash=W.decode(e.Hash)}catch(e){}if(!t.Hash)throw new Error("Invalid Hash field found in link, expected CID");return void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),r}const Ue=["string","number","bigint","symbol"],_e=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];class Le{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Le.uint=new Le(0,"uint",!0),Le.negint=new Le(1,"negint",!0),Le.bytes=new Le(2,"bytes",!0),Le.string=new Le(3,"string",!0),Le.array=new Le(4,"array",!1),Le.map=new Le(5,"map",!1),Le.tag=new Le(6,"tag",!1),Le.float=new Le(7,"float",!0),Le.false=new Le(7,"false",!0),Le.true=new Le(7,"true",!0),Le.null=new Le(7,"null",!0),Le.undefined=new Le(7,"undefined",!0),Le.break=new Le(7,"break",!0);class Me{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const ze=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,He=new TextDecoder,Fe=new TextEncoder;function Ge(e){return ze&&globalThis.Buffer.isBuffer(e)}function Re(e){return e instanceof Uint8Array?Ge(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const Ve=ze?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):Ye(e,t,r):(e,t,r)=>r-t>64?He.decode(e.subarray(t,r)):Ye(e,t,r),qe=ze?e=>e.length>64?globalThis.Buffer.from(e):Ze(e):e=>e.length>64?Fe.encode(e):Ze(e),Je=e=>Uint8Array.from(e),We=ze?(e,t,r)=>Ge(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r),Ke=ze?(e,t)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),Re(globalThis.Buffer.concat(e,t))):(e,t)=>{const r=new Uint8Array(t);let n=0;for(let t of e)n+t.length>r.length&&(t=t.subarray(0,r.length-n)),r.set(t,n),n+=t.length;return r},Qe=ze?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function Ze(e,t=1/0){let r;const n=e.length;let o=null;const i=[];for(let s=0;s<n;++s){if(r=e.charCodeAt(s),r>55295&&r<57344){if(!o){if(r>56319){(t-=3)>-1&&i.push(239,191,189);continue}if(s+1===n){(t-=3)>-1&&i.push(239,191,189);continue}o=r;continue}if(r<56320){(t-=3)>-1&&i.push(239,191,189),o=r;continue}r=65536+(o-55296<<10|r-56320)}else o&&(t-=3)>-1&&i.push(239,191,189);if(o=null,r<128){if((t-=1)<0)break;i.push(r)}else if(r<2048){if((t-=2)<0)break;i.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;i.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return i}function Ye(e,t,r){const n=[];for(;t<r;){const o=e[t];let i=null,s=o>239?4:o>223?3:o>191?2:1;if(t+s<=r){let r,n,a,c;switch(s){case 1:o<128&&(i=o);break;case 2:r=e[t+1],128==(192&r)&&(c=(31&o)<<6|63&r,c>127&&(i=c));break;case 3:r=e[t+1],n=e[t+2],128==(192&r)&&128==(192&n)&&(c=(15&o)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:r=e[t+1],n=e[t+2],a=e[t+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(c=(15&o)<<18|(63&r)<<12|(63&n)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,s=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),t+=s}return function(e){const t=e.length;if(t<=Xe)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=Xe));return r}(n)}const Xe=4096;class et{constructor(e=256){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const r=t.length-(this.maxCursor-this.cursor)-1;t.set(e,r)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=Qe(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(1===this.chunks.length){const r=this.chunks[0];e&&this.cursor>r.length/2?(t=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=We(r,0,this.cursor)}else t=Ke(this.chunks,this.cursor);return e&&this.reset(),t}}const tt="CBOR decode error:",rt="CBOR encode error:",nt=[];function ot(e,t,r){if(e.length-t<r)throw new Error(`${tt} not enough data for type`)}nt[23]=1,nt[24]=2,nt[25]=3,nt[26]=5,nt[27]=9;const it=[24,256,65536,4294967296,BigInt("18446744073709551616")];function st(e,t,r){ot(e,t,1);const n=e[t];if(!0===r.strict&&n<it[0])throw new Error(`${tt} integer encoded in more bytes than necessary (strict decode)`);return n}function at(e,t,r){ot(e,t,2);const n=e[t]<<8|e[t+1];if(!0===r.strict&&n<it[1])throw new Error(`${tt} integer encoded in more bytes than necessary (strict decode)`);return n}function ct(e,t,r){ot(e,t,4);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===r.strict&&n<it[2])throw new Error(`${tt} integer encoded in more bytes than necessary (strict decode)`);return n}function ut(e,t,r){ot(e,t,8);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(n)<<BigInt(32))+BigInt(o);if(!0===r.strict&&i<it[3])throw new Error(`${tt} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===r.allowBigInt)return i;throw new Error(`${tt} integers outside of the safe integer range are not supported`)}function ht(e,t){return lt(e,0,t.value)}function lt(e,t,r){if(r<it[0]){const n=Number(r);e.push([t|n])}else if(r<it[1]){const n=Number(r);e.push([24|t,n])}else if(r<it[2]){const n=Number(r);e.push([25|t,n>>>8,255&n])}else if(r<it[3]){const n=Number(r);e.push([26|t,n>>>24&255,n>>>16&255,n>>>8&255,255&n])}else{const n=BigInt(r);if(!(n<it[4]))throw new Error(`${tt} encountered BigInt larger than allowable range`);{const r=[27|t,0,0,0,0,0,0,0];let o=Number(n&BigInt(4294967295)),i=Number(n>>BigInt(32)&BigInt(4294967295));r[8]=255&o,o>>=8,r[7]=255&o,o>>=8,r[6]=255&o,o>>=8,r[5]=255&o,r[4]=255&i,i>>=8,r[3]=255&i,i>>=8,r[2]=255&i,i>>=8,r[1]=255&i,e.push(r)}}}ht.encodedSize=function(e){return lt.encodedSize(e.value)},lt.encodedSize=function(e){return e<it[0]?1:e<it[1]?2:e<it[2]?3:e<it[3]?5:9},ht.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const ft=BigInt(-1),dt=BigInt(1);function yt(e,t){const r=t.value,n="bigint"==typeof r?r*ft-dt:-1*r-1;lt(e,t.type.majorEncoded,n)}function pt(e,t,r,n){ot(e,t,r+n);const o=We(e,t+r,t+r+n);return new Me(Le.bytes,o,r+n)}function wt(e,t,r,n){return pt(e,t,1,r)}function gt(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===Le.string?qe(e.value):e.value),e.encodedBytes}function bt(e,t){const r=gt(t);lt(e,t.type.majorEncoded,r.length),e.push(r)}function mt(e,t,r,n,o){const i=r+n;ot(e,t,i);const s=new Me(Le.string,Ve(e,t+r,t+i),i);return!0===o.retainStringBytes&&(s.byteValue=We(e,t+r,t+i)),s}function vt(e,t,r,n){return mt(e,t,1,r,n)}yt.encodedSize=function(e){const t=e.value,r="bigint"==typeof t?t*ft-dt:-1*t-1;return r<it[0]?1:r<it[1]?2:r<it[2]?3:r<it[3]?5:9},yt.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},bt.encodedSize=function(e){const t=gt(e);return lt.encodedSize(t.length)+t.length},bt.compareTokens=function(e,t){return r=gt(e),n=gt(t),r.length<n.length?-1:r.length>n.length?1:function(e,t){if(Ge(e)&&Ge(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}(r,n);var r,n};const Et=bt;function kt(e,t,r,n){return new Me(Le.array,n,r)}function xt(e,t,r,n){return kt(0,0,1,r)}function At(e,t){lt(e,Le.array.majorEncoded,t.value)}function It(e,t,r,n){return new Me(Le.map,n,r)}function Tt(e,t,r,n){return It(0,0,1,r)}function Nt(e,t){lt(e,Le.map.majorEncoded,t.value)}function Ct(e,t,r,n){return new Me(Le.tag,r,1)}function jt(e,t){lt(e,Le.tag.majorEncoded,t.value)}function Bt(e,t,r){if(r){if(!1===r.allowNaN&&Number.isNaN(e))throw new Error(`${tt} NaN values are not supported`);if(!1===r.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${tt} Infinity values are not supported`)}return new Me(Le.float,e,t)}function St(e,t,r){const n=t.value;if(!1===n)e.push([20|Le.float.majorEncoded]);else if(!0===n)e.push([21|Le.float.majorEncoded]);else if(null===n)e.push([22|Le.float.majorEncoded]);else if(void 0===n)e.push([23|Le.float.majorEncoded]);else{let t,i=!1;r&&!0===r.float64||(Ot(n),t=Ut(Pt,1),n===t||Number.isNaN(n)?(Pt[0]=249,e.push(Pt.slice(0,3)),i=!0):(_t(n),t=Lt(Pt,1),n===t&&(Pt[0]=250,e.push(Pt.slice(0,5)),i=!0))),i||(o=n,$t.setFloat64(0,o,!1),t=Mt(Pt,1),Pt[0]=251,e.push(Pt.slice(0,9)))}var o}At.compareTokens=ht.compareTokens,At.encodedSize=function(e){return lt.encodedSize(e.value)},Nt.compareTokens=ht.compareTokens,Nt.encodedSize=function(e){return lt.encodedSize(e.value)},jt.compareTokens=ht.compareTokens,jt.encodedSize=function(e){return lt.encodedSize(e.value)},St.encodedSize=function(e,t){const r=e.value;if(!1===r||!0===r||null==r)return 1;if(!t||!0!==t.float64){Ot(r);let e=Ut(Pt,1);if(r===e||Number.isNaN(r))return 3;if(_t(r),e=Lt(Pt,1),r===e)return 5}return 9};const Dt=new ArrayBuffer(9),$t=new DataView(Dt,1),Pt=new Uint8Array(Dt,0);function Ot(e){if(e===1/0)$t.setUint16(0,31744,!1);else if(e===-1/0)$t.setUint16(0,64512,!1);else if(Number.isNaN(e))$t.setUint16(0,32256,!1);else{$t.setFloat32(0,e);const t=$t.getUint32(0),r=(2139095040&t)>>23,n=8388607&t;if(255===r)$t.setUint16(0,31744,!1);else if(0===r)$t.setUint16(0,(2147483648&e)>>16|n>>13,!1);else{const e=r-127;e<-24?$t.setUint16(0,0):e<-14?$t.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):$t.setUint16(0,(2147483648&t)>>16|e+15<<10|n>>13,!1)}}}function Ut(e,t){if(e.length-t<2)throw new Error(`${tt} not enough data for float16`);const r=(e[t]<<8)+e[t+1];if(31744===r)return 1/0;if(64512===r)return-1/0;if(32256===r)return NaN;const n=r>>10&31,o=1023&r;let i;return i=0===n?o*2**-24:31!==n?(o+1024)*2**(n-25):0===o?1/0:NaN,32768&r?-i:i}function _t(e){$t.setFloat32(0,e,!1)}function Lt(e,t){if(e.length-t<4)throw new Error(`${tt} not enough data for float32`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,4).getFloat32(0,!1)}function Mt(e,t){if(e.length-t<8)throw new Error(`${tt} not enough data for float64`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,8).getFloat64(0,!1)}function zt(e,t,r){throw new Error(`${tt} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function Ht(e){return()=>{throw new Error(`${tt} ${e}`)}}St.compareTokens=ht.compareTokens;const Ft=[];for(let e=0;e<=23;e++)Ft[e]=zt;Ft[24]=function(e,t,r,n){return new Me(Le.uint,st(e,t+1,n),2)},Ft[25]=function(e,t,r,n){return new Me(Le.uint,at(e,t+1,n),3)},Ft[26]=function(e,t,r,n){return new Me(Le.uint,ct(e,t+1,n),5)},Ft[27]=function(e,t,r,n){return new Me(Le.uint,ut(e,t+1,n),9)},Ft[28]=zt,Ft[29]=zt,Ft[30]=zt,Ft[31]=zt;for(let e=32;e<=55;e++)Ft[e]=zt;Ft[56]=function(e,t,r,n){return new Me(Le.negint,-1-st(e,t+1,n),2)},Ft[57]=function(e,t,r,n){return new Me(Le.negint,-1-at(e,t+1,n),3)},Ft[58]=function(e,t,r,n){return new Me(Le.negint,-1-ct(e,t+1,n),5)},Ft[59]=function(e,t,r,n){const o=ut(e,t+1,n);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new Me(Le.negint,e,9)}if(!0!==n.allowBigInt)throw new Error(`${tt} integers outside of the safe integer range are not supported`);return new Me(Le.negint,ft-BigInt(o),9)},Ft[60]=zt,Ft[61]=zt,Ft[62]=zt,Ft[63]=zt;for(let e=64;e<=87;e++)Ft[e]=wt;Ft[88]=function(e,t,r,n){return pt(e,t,2,st(e,t+1,n))},Ft[89]=function(e,t,r,n){return pt(e,t,3,at(e,t+1,n))},Ft[90]=function(e,t,r,n){return pt(e,t,5,ct(e,t+1,n))},Ft[91]=function(e,t,r,n){const o=ut(e,t+1,n);if("bigint"==typeof o)throw new Error(`${tt} 64-bit integer bytes lengths not supported`);return pt(e,t,9,o)},Ft[92]=zt,Ft[93]=zt,Ft[94]=zt,Ft[95]=Ht("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)Ft[e]=vt;Ft[120]=function(e,t,r,n){return mt(e,t,2,st(e,t+1,n),n)},Ft[121]=function(e,t,r,n){return mt(e,t,3,at(e,t+1,n),n)},Ft[122]=function(e,t,r,n){return mt(e,t,5,ct(e,t+1,n),n)},Ft[123]=function(e,t,r,n){const o=ut(e,t+1,n);if("bigint"==typeof o)throw new Error(`${tt} 64-bit integer string lengths not supported`);return mt(e,t,9,o,n)},Ft[124]=zt,Ft[125]=zt,Ft[126]=zt,Ft[127]=Ht("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)Ft[e]=xt;Ft[152]=function(e,t,r,n){return kt(0,0,2,st(e,t+1,n))},Ft[153]=function(e,t,r,n){return kt(0,0,3,at(e,t+1,n))},Ft[154]=function(e,t,r,n){return kt(0,0,5,ct(e,t+1,n))},Ft[155]=function(e,t,r,n){const o=ut(e,t+1,n);if("bigint"==typeof o)throw new Error(`${tt} 64-bit integer array lengths not supported`);return kt(0,0,9,o)},Ft[156]=zt,Ft[157]=zt,Ft[158]=zt,Ft[159]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${tt} indefinite length items not allowed`);return kt(0,0,1,1/0)};for(let e=160;e<=183;e++)Ft[e]=Tt;Ft[184]=function(e,t,r,n){return It(0,0,2,st(e,t+1,n))},Ft[185]=function(e,t,r,n){return It(0,0,3,at(e,t+1,n))},Ft[186]=function(e,t,r,n){return It(0,0,5,ct(e,t+1,n))},Ft[187]=function(e,t,r,n){const o=ut(e,t+1,n);if("bigint"==typeof o)throw new Error(`${tt} 64-bit integer map lengths not supported`);return It(0,0,9,o)},Ft[188]=zt,Ft[189]=zt,Ft[190]=zt,Ft[191]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${tt} indefinite length items not allowed`);return It(0,0,1,1/0)};for(let e=192;e<=215;e++)Ft[e]=Ct;Ft[216]=function(e,t,r,n){return new Me(Le.tag,st(e,t+1,n),2)},Ft[217]=function(e,t,r,n){return new Me(Le.tag,at(e,t+1,n),3)},Ft[218]=function(e,t,r,n){return new Me(Le.tag,ct(e,t+1,n),5)},Ft[219]=function(e,t,r,n){return new Me(Le.tag,ut(e,t+1,n),9)},Ft[220]=zt,Ft[221]=zt,Ft[222]=zt,Ft[223]=zt;for(let e=224;e<=243;e++)Ft[e]=Ht("simple values are not supported");Ft[244]=zt,Ft[245]=zt,Ft[246]=zt,Ft[247]=function(e,t,r,n){if(!1===n.allowUndefined)throw new Error(`${tt} undefined values are not supported`);return!0===n.coerceUndefinedToNull?new Me(Le.null,null,1):new Me(Le.undefined,void 0,1)},Ft[248]=Ht("simple values are not supported"),Ft[249]=function(e,t,r,n){return Bt(Ut(e,t+1),3,n)},Ft[250]=function(e,t,r,n){return Bt(Lt(e,t+1),5,n)},Ft[251]=function(e,t,r,n){return Bt(Mt(e,t+1),9,n)},Ft[252]=zt,Ft[253]=zt,Ft[254]=zt,Ft[255]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${tt} indefinite length items not allowed`);return new Me(Le.break,void 0,1)};const Gt=[];for(let e=0;e<24;e++)Gt[e]=new Me(Le.uint,e,1);for(let e=-1;e>=-24;e--)Gt[31-e]=new Me(Le.negint,e,1);Gt[64]=new Me(Le.bytes,new Uint8Array(0),1),Gt[96]=new Me(Le.string,"",1),Gt[128]=new Me(Le.array,0,1),Gt[160]=new Me(Le.map,0,1),Gt[244]=new Me(Le.false,!1,1),Gt[245]=new Me(Le.true,!0,1),Gt[246]=new Me(Le.null,null,1);const Rt={float64:!1,mapSorter:function(e,t){const r=Array.isArray(e[0])?e[0][0]:e[0],n=Array.isArray(t[0])?t[0][0]:t[0];if(r.type!==n.type)return r.type.compare(n.type);const o=r.type.major,i=Vt[o].compareTokens(r,n);return 0===i&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),i},quickEncodeToken:function(e){switch(e.type){case Le.false:return Je([244]);case Le.true:return Je([245]);case Le.null:return Je([246]);case Le.bytes:return e.value.length?void 0:Je([64]);case Le.string:return""===e.value?Je([96]):void 0;case Le.array:return 0===e.value?Je([128]):void 0;case Le.map:return 0===e.value?Je([160]):void 0;case Le.uint:return e.value<24?Je([Number(e.value)]):void 0;case Le.negint:if(e.value>=-24)return Je([31-Number(e.value)])}}},Vt=function(){const e=[];return e[Le.uint.major]=ht,e[Le.negint.major]=yt,e[Le.bytes.major]=bt,e[Le.string.major]=Et,e[Le.array.major]=At,e[Le.map.major]=Nt,e[Le.tag.major]=jt,e[Le.float.major]=St,e}(),qt=new et;class Jt{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${rt} object contains circular references`);return new Jt(t,e)}}const Wt={null:new Me(Le.null,null),undefined:new Me(Le.undefined,void 0),true:new Me(Le.true,!0),false:new Me(Le.false,!1),emptyArray:new Me(Le.array,0),emptyMap:new Me(Le.map,0)},Kt={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new Me(e>=0?Le.uint:Le.negint,e):new Me(Le.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new Me(Le.uint,e):new Me(Le.negint,e),Uint8Array:(e,t,r,n)=>new Me(Le.bytes,e),string:(e,t,r,n)=>new Me(Le.string,e),boolean:(e,t,r,n)=>e?Wt.true:Wt.false,null:(e,t,r,n)=>Wt.null,undefined:(e,t,r,n)=>Wt.undefined,ArrayBuffer:(e,t,r,n)=>new Me(Le.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new Me(Le.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[Wt.emptyArray,new Me(Le.break)]:Wt.emptyArray;n=Jt.createCheck(n,e);const o=[];let i=0;for(const t of e)o[i++]=Qt(t,r,n);return r.addBreakTokens?[new Me(Le.array,e.length),o,new Me(Le.break)]:[new Me(Le.array,e.length),o]},Object(e,t,r,n){const o="Object"!==t,i=o?e.keys():Object.keys(e),s=o?e.size:i.length;if(!s)return!0===r.addBreakTokens?[Wt.emptyMap,new Me(Le.break)]:Wt.emptyMap;n=Jt.createCheck(n,e);const a=[];let c=0;for(const t of i)a[c++]=[Qt(t,r,n),Qt(o?e.get(t):e[t],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(a,r),r.addBreakTokens?[new Me(Le.map,s),a,new Me(Le.break)]:[new Me(Le.map,s),a]}};Kt.Map=Kt.Object,Kt.Buffer=Kt.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Kt[`${e}Array`]=Kt.DataView;function Qt(e,t={},r){const n=function(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(Ue.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";return function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(_e.includes(t))return t}(e)||"Object"}(e),o=t&&t.typeEncoders&&t.typeEncoders[n]||Kt[n];if("function"==typeof o){const i=o(e,n,t,r);if(null!=i)return i}const i=Kt[n];if(!i)throw new Error(`${rt} unsupported type: ${n}`);return i(e,n,t,r)}function Zt(e,t,r,n){if(Array.isArray(t))for(const o of t)Zt(e,o,r,n);else r[t.type.major](e,t,n)}function Yt(e,t,r){const n=Qt(e,r);if(!Array.isArray(n)&&r.quickEncodeToken){const e=r.quickEncodeToken(n);if(e)return e;const o=t[n.type.major];if(o.encodedSize){const e=o.encodedSize(n,r),t=new et(e);if(o(t,n,r),1!==t.chunks.length)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return Re(t.chunks[0])}}return qt.reset(),Zt(qt,n,t,r),qt.toBytes(!0)}const Xt={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class er{constructor(e,t={}){this.pos=0,this.data=e,this.options=t}done(){return this.pos>=this.data.length}next(){const e=this.data[this.pos];let t=Gt[e];if(void 0===t){const r=Ft[e];if(!r)throw new Error(`${tt} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const n=31&e;t=r(this.data,this.pos,n,this.options)}return this.pos+=t.encodedLength,t}}const tr=Symbol.for("DONE"),rr=Symbol.for("BREAK");function nr(e,t){if(e.done())return tr;const r=e.next();if(r.type===Le.break)return rr;if(r.type.terminal)return r.value;if(r.type===Le.array)return function(e,t,r){const n=[];for(let o=0;o<e.value;o++){const i=nr(t,r);if(i===rr){if(e.value===1/0)break;throw new Error(`${tt} got unexpected break to lengthed array`)}if(i===tr)throw new Error(`${tt} found array but not enough entries (got ${o}, expected ${e.value})`);n[o]=i}return n}(r,e,t);if(r.type===Le.map)return function(e,t,r){const n=!0===r.useMaps,o=n?void 0:{},i=n?new Map:void 0;for(let s=0;s<e.value;s++){const a=nr(t,r);if(a===rr){if(e.value===1/0)break;throw new Error(`${tt} got unexpected break to lengthed map`)}if(a===tr)throw new Error(`${tt} found map but not enough entries (got ${s} [no key], expected ${e.value})`);if(!0!==n&&"string"!=typeof a)throw new Error(`${tt} non-string keys not supported (got ${typeof a})`);if(!0===r.rejectDuplicateMapKeys&&(n&&i.has(a)||!n&&a in o))throw new Error(`${tt} found repeat map key "${a}"`);const c=nr(t,r);if(c===tr)throw new Error(`${tt} found map but not enough entries (got ${s} [no value], expected ${e.value})`);n?i.set(a,c):o[a]=c}return n?i:o}(r,e,t);if(r.type===Le.tag){if(t.tags&&"function"==typeof t.tags[r.value]){const n=nr(e,t);return t.tags[r.value](n)}throw new Error(`${tt} tag not supported (${r.value})`)}throw new Error("unsupported")}const or={float64:!0,typeEncoders:{Object:function(e){if(e.asCID!==e&&e["/"]!==e.bytes)return null;const t=W.asCID(e);if(!t)return null;const r=new Uint8Array(t.bytes.byteLength+1);return r.set(t.bytes,1),[new Me(Le.tag,42),new Me(Le.bytes,r)]},undefined:function(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")},number:function(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}}},ir={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};ir.tags[42]=function(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return W.decode(e.subarray(1))};const sr="dag-cbor",ar=113,cr=e=>{return t=e,r=or,r=Object.assign({},Rt,r),Yt(t,Vt,r);var t,r},ur=e=>function(e,t){if(!(e instanceof Uint8Array))throw new Error(`${tt} data to decode must be a Uint8Array`);const r=(t=Object.assign({},Xt,t)).tokenizer||new er(e,t),n=nr(r,t);if(n===tr)throw new Error(`${tt} did not find any content to decode`);if(n===rr)throw new Error(`${tt} got unexpected break`);if(!r.done())throw new Error(`${tt} too many terminals, data makes no sense`);return n}(e,ir),hr=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),lr=re({name:"sha2-256",code:18,encode:hr("SHA-256")}),fr=(re({name:"sha2-512",code:19,encode:hr("SHA-512")}),G),dr=()=>new Error("unsupported codec"),yr=e=>e?Array.isArray(e)?e.map(yr):W.parse(e):e,pr=(e,t={})=>{if(!e||"string"==typeof e)return e;if(Array.isArray(e))return e.map(pr);const r=t.base||fr;return e.toString(r)},wr={[$e]:e,[ar]:t},gr={raw:t,"dag-pb":e,"dag-cbor":t};async function br(e,t,r={}){t=yr(pr(t));const n=wr[t.code];if(!n)throw dr();const o=await e.block.get(t,{timeout:r.timeout}),i=await async function({bytes:e,codec:t,hasher:r}){if(!e)throw new Error('Missing required argument "bytes"');if(!t||!r)throw new Error("Missing required argument: codec or hasher");const n=t.decode(e),o=await r.digest(e),i=W.create(1,t.code,o);return new ue({value:n,bytes:e,cid:i})}({bytes:o,codec:n,hasher:lr});if(i.cid.code===$e)return JSON.parse((new TextDecoder).decode(i.value.Data));if(i.cid.code===ar){const e=i.value;return(r.links||[]).forEach((t=>{e[t]&&(e[t]=pr(e[t],r))})),e}}async function mr(e,t,r,n={}){"dag-pb"===n.format&&(t=n.format);const o=gr[t];if(!o)throw dr();o.code===$e&&(r="string"==typeof r?r:JSON.stringify(r),r={Data:(new TextEncoder).encode(r),Links:[]}),o.code===ar&&(n.links||[]).forEach((e=>{r[e]&&(r[e]=yr(r[e]))}));const i=await async function({value:e,codec:t,hasher:r}){if(void 0===e)throw new Error('Missing required argument "value"');if(!t||!r)throw new Error("Missing required argument: codec or hasher");const n=t.encode(e),o=await r.digest(n),i=W.create(1,t.code,o);return new ue({value:e,bytes:n,cid:i})}({value:r,codec:o,hasher:lr});return await e.block.put(i.bytes,{cid:i.cid.bytes,version:i.cid.version,format:t,mhtype:"sha2-256",pin:n.pin,timeout:n.timeout}),(o.code===$e?i.cid.toV0():i.cid).toString(n.base||fr)}const vr=e=>null!=e;var Er=r(299);const kr=()=>new Error("Ipfs instance not defined"),xr=["next","refs"],Ar=e=>0===e?"dag-pb":"dag-cbor",Ir=e=>Tr.isEntry(e)?Ar(e.v):Ar(e);class Tr{static async create(e,t,r,n,o=[],i,s=[],a){if(!vr(e))throw kr();if(!vr(t))throw new Error("Identity is required, cannot create entry");if(!vr(r))throw new Error("Entry requires an id");if(!vr(n))throw new Error("Entry requires data");if(!vr(o)||!Array.isArray(o))throw new Error("'next' argument is not an array");const c={hash:null,id:r,payload:n,next:o.filter(vr).map((e=>e.hash?e.hash:e)),refs:s,v:2,clock:i||new w(t.publicKey)},u=await t.provider.sign(t,Tr.toBuffer(c));return c.key=t.publicKey,c.identity=t.toJSON(),c.sig=u,c.hash=await Tr.toMultihash(e,c,a),c}static async verify(e,t){if(!e)throw new Error("Identity-provider is required, cannot verify entry");if(!Tr.isEntry(t))throw new Error("Invalid Log entry");if(!t.key)throw new Error("Entry doesn't have a key");if(!t.sig)throw new Error("Entry doesn't have a signature");const r=Tr.toEntry(t,{presigned:!0}),n=t.v<1?"v0":"v1";return e.verify(t.sig,t.key,Tr.toBuffer(r),n)}static toBuffer(e){const t=0===e.v?JSON.stringify(e):Er(e);return Buffer.from(t)}static async toMultihash(e,t,r=!1){if(!e)throw kr();if(!Tr.isEntry(t))throw new Error("Invalid object format, cannot generate entry hash");const n=Tr.toEntry(t);return mr(e,Ir(n.v),n,{links:xr,pin:r})}static toEntry(e,{presigned:t=!1,includeHash:r=!1}={}){const n={hash:r?e.hash:null,id:e.id,payload:e.payload,next:e.next},o=e.v;return o>1&&(n.refs=e.refs),n.v=e.v,n.clock=new w(e.clock.id,e.clock.time),t||(n.key=e.key,o>0&&(n.identity=e.identity),n.sig=e.sig),n}static async fromMultihash(e,t){if(!e)throw kr();if(!t)throw new Error(`Invalid hash: ${t}`);const r=await br(e,t,{links:xr}),n=Tr.toEntry(r);return n.hash=t,n}static isEntry(e){return e&&void 0!==e.id&&void 0!==e.next&&void 0!==e.payload&&void 0!==e.v&&void 0!==e.hash&&void 0!==e.clock&&(void 0!==e.refs||e.v<2)}static compare(e,t){const r=w.compare(e.clock,t.clock);return 0===r?e.clock.id<t.clock.id?-1:1:r}static isEqual(e,t){return e.hash===t.hash}static isParent(e,t){return t.next.indexOf(e.hash)>-1}static findChildren(e,t){let r=[],n=t.find((t=>Tr.isParent(e,t))),o=e;for(;n;)r.push(n),o=n,n=t.find((e=>Tr.isParent(o,e)));return r=r.sort(((e,t)=>e.clock.time>t.clock.time)),r}}const Nr=Tr;async function Cr(e,t){if(t(await e()))return Cr(e,t)}const{isEntry:jr,fromMultihash:Br}=Nr,Sr=e=>e&&e.length>0;class Dr{static async fetchParallel(e,t,{length:r,exclude:n=[],shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:a}){return(await f(t,(async t=>Dr.fetchAll(e,t,{length:r,exclude:n,shouldExclude:o,timeout:i,onProgressCallback:a,concurrency:s})),{concurrency:Math.max(s||t.length,1)})).reduce(((e,t)=>e.concat(t)),[])}static async fetchAll(e,t,{length:r=-1,exclude:n=[],shouldExclude:o,timeout:i,onProgressCallback:s,onStartProgressCallback:a,concurrency:c=32,delay:u=0}={}){const h=[],l={},d={},y=Array.isArray(t)?{0:t.slice()}:{0:[t]};let p=0,w=0,g=0;o=o||(()=>!1);const b=(e,t)=>{d[e]||o(e)||(y[t]||(y[t]=[]),y[t].includes(e)||y[t].push(e),d[e]=!0)},m=async t=>{if(t&&!l[t]&&!o(t))return new Promise((async(n,c)=>{const f=i&&i>0?setTimeout((()=>{console.warn(`Warning: Couldn't fetch entry '${t}', request timed out (${i}ms)`),n()}),i):null;a&&a(t,null,0,h.length);try{const i=await Br(e,t);if(u>0){const e=(e=0)=>new Promise((t=>setTimeout(t,e)));await e(u)}(e=>{if(jr(e)&&!l[e.hash]&&!o(e.hash)){const t=e.clock.time;w=Math.max(w,t),g=h.length>0?Math.min(h[h.length-1].clock.time,g):w;const n=h.length>=r&&t>=g,i=e=>w-t+(e+1)*e;!(r<0||h.length<r||n)||o(e.hash)||l[e.hash]||(h.push(e),l[e.hash]=!0,s&&s(e)),r<0?(e.next.forEach(b),e.refs&&e.refs.forEach(b)):((h.length<r||t>g||t===g&&!l[e.hash]&&!o(e.hash))&&e.next.forEach((e=>b(e,i(0)))),e.refs&&h.length+e.refs.length<=r&&e.refs.forEach(((e,t)=>b(e,i(t)))))}})(i),n()}catch(e){c(e)}finally{clearTimeout(f)}}))};return n.forEach((e=>{l[e.hash||e]=!0})),await Cr((async()=>{if(p<c){const e=((e=1)=>Object.keys(y).reduce(((t,r,n)=>{const o=y[r];for(;o.length>0&&t.length<e;){const e=o.shift();t.push(e)}return 0===o.length&&delete y[r],t}),[]))(c);p+=e.length,await f(e,m,{concurrency:c}),p-=e.length}}),(()=>void 0!==Object.values(y).find(Sr))),h}}const $r=Dr;function Pr(e,t,r){const n=w.compare(e.clock,t.clock);return 0===n?r(e,t):n}function Or(e,t,r){return e.clock.id===t.clock.id?r(e,t):e.clock.id<t.clock.id?-1:1}const Ur={SortByClocks:Pr,SortByClockId:Or,LastWriteWins:function(e,t){const r=(e,t)=>e,n=(e,t)=>Or(e,t,r);return((e,t)=>Pr(e,t,n))(e,t)},SortByEntryHash:function(e,t){const r=(e,t)=>e.hash<t.hash?-1:1,n=(e,t)=>Or(e,t,r);return((e,t)=>Pr(e,t,n))(e,t)},NoZeroes:function(e){const t=`Your log's tiebreaker function, ${e.name}, has returned zero and therefore cannot be`;return(r,n)=>{const o=e(r,n);if(0===o)throw Error(t);return o}}},_r=()=>new Error("IPFS instance not defined"),Lr=()=>new Error("Log instance not defined"),Mr=()=>new Error("Given argument is not an instance of Log"),zr=()=>new Error("lt or lte must be a string or array of Entries"),Hr=function(e,t){const r={};return e.forEach((e=>r[t?e[t]:e]=e)),Object.keys(r).map((e=>r[e]))},{LastWriteWins:Fr,NoZeroes:Gr}=Ur,{fetchAll:Rr,fetchParallel:Vr}=$r,{compare:qr,isEntry:Jr}=Nr,Wr=["heads"],Kr=(e,t)=>e.slice(e.length-Math.min(e.length,t),e.length),Qr=class{static async toMultihash(e,t,{format:r}={}){if(!vr(e))throw _r();if(!vr(t))throw Lr();if(vr(r)||(r="dag-cbor"),t.values.length<1)throw new Error("Can't serialize an empty log");return mr(e,r,t.toJSON(),{links:Wr})}static async fromMultihash(e,t,{length:r=-1,exclude:n=[],shouldExclude:o,timeout:i,concurrency:s,sortFn:a,onProgressCallback:c}){if(!vr(e))throw _r();if(!vr(t))throw new Error(`Invalid hash: ${t}`);const u=await br(e,t,{links:Wr});if(!u.heads||!u.id)throw Mr();a=a||Gr(Fr);const h=await Rr(e,u.heads,{length:r,exclude:n,shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:c}),l=u.id,f=r>-1?Kr(h.sort(a),r):h,d=f.filter((e=>u.heads.includes(e.hash)));return{logId:l,entries:f,heads:d}}static async fromEntryHash(e,t,{length:r=-1,exclude:n=[],shouldExclude:o,timeout:i,concurrency:s,sortFn:a,onProgressCallback:c}){if(!vr(e))throw _r();if(!vr(t))throw new Error("'hash' must be defined");const u=Array.isArray(t)?t:[t];r=r>-1?Math.max(r,1):r;const h=await Vr(e,u,{length:r,exclude:n,shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:c});return a=a||Gr(Fr),{entries:r>-1?Kr(h.sort(a),r):h}}static async fromJSON(e,t,{length:r=-1,timeout:n,concurrency:o,onProgressCallback:i}){if(!vr(e))throw _r();const{id:s,heads:a}=t,c=a.map((e=>e.hash));return{logId:s,entries:(await Vr(e,c,{length:r,timeout:n,concurrency:o,onProgressCallback:i})).sort(qr),heads:a}}static async fromEntry(e,t,{length:r=-1,exclude:n=[],shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:a}){if(!vr(e))throw _r();if(!vr(t))throw new Error("'sourceEntries' must be defined");if(!Array.isArray(t)&&!Jr(t))throw new Error("'sourceEntries' argument must be an array of Entry instances or a single Entry");Array.isArray(t)||(t=[t]),r=r>-1?Math.max(r,t.length):r;const c=t.map((e=>e.hash)),u=await Vr(e,c,{length:r,exclude:n,shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:a}),h=t.concat(u).concat(n),l=Hr(h,"hash").sort(qr),f=l.slice(r>-1?-r:-l.length),d=((e,t)=>{const r=e.slice(t.length,e.length);return t.concat(r)})(f,function(e,t,r){const n={},o={};return e.forEach((e=>o[r?e[r]:e]=!0)),t.reduce(((e,t)=>{const i=void 0!==o[r?t[r]:t],s=void 0!==n[r?t[r]:t];return i||s||(e.push(t),n[r?t[r]:t]=!0),e}),[])}(f,t,"hash"));return{logId:d[d.length-1].id,entries:d}}},Zr=class{async canAppend(e,t){return!0}},Yr=class{constructor(e={}){this._cache=e}set(e,t){this._cache[e]=t}get(e){return this._cache[e]}delete(e){return delete this._cache[e]}add(e){this._cache=Object.assign(this._cache,e)}get length(){return Object.values(this._cache).length}},{LastWriteWins:Xr,NoZeroes:en}=Ur,tn=e=>e.hash,rn=(e,t)=>e.concat(t),nn=e=>e.next,on=(e,t)=>Math.max(e,t.clock.time),sn=(e,t)=>(e[t.hash]=t,e);class an extends y{constructor(e,t,{logId:r,access:n,entries:o,heads:i,clock:s,sortFn:a,concurrency:c}={}){if(!vr(e))throw _r();if(!vr(t))throw new Error("Identity is required");if(vr(n)||(n=new Zr),vr(o)&&!Array.isArray(o))throw new Error("'entries' argument must be an array of Entry instances");if(vr(i)&&!Array.isArray(i))throw new Error("'heads' argument must be an array");vr(a)||(a=Xr),super(),this._sortFn=en(a),this._storage=e,this._id=r||(new Date).getTime().toString(),this._access=n,this._identity=t;const u=(o||[]).reduce(sn,{});this._entryIndex=new Yr(u),o=Object.values(u)||[],i=i||an.findHeads(o),this._headsIndex=i.reduce(sn,{}),this._nextsIndex={},o.forEach((e=>e.next.forEach((t=>this._nextsIndex[t]=e.hash)))),this._length=o.length;const h=Math.max(s?s.time:0,this.heads.reduce(on,0));this._clock=new w(this._identity.publicKey,h),this.joinConcurrency=c||16}get id(){return this._id}get clock(){return this._clock}get length(){return this._length}get values(){return Object.values(this.traverse(this.heads)).reverse()}get heads(){return Object.values(this._headsIndex).sort(this._sortFn).reverse()}get tails(){return an.findTails(this.values)}get tailHashes(){return an.findTailHashes(this.values)}setIdentity(e){this._identity=e;const t=Math.max(this.clock.time,this.heads.reduce(on,0));this._clock=new w(this._identity.publicKey,t)}get(e){return this._entryIndex.get(e)}has(e){return void 0!==this._entryIndex.get(e.hash||e)}traverse(e,t=-1,r){let n=e.sort(this._sortFn).reverse(),o={};const i={};let s=0;const a=e=>this.get(e),c=e=>{e&&!o[e.hash]&&(n=[e,...n].sort(this._sortFn).reverse(),o[e.hash]=!0)};for(;n.length>0&&(s<t||t<0);){const e=n.shift();if(i[(u=e).hash]=u,o[u.hash]=!0,s++,r&&r===e.hash)break;e.next.map(a).filter(vr).forEach(c)}var u;return n=[],o={},i}async append(e,t=1,r=!1){const n=Math.max(this.clock.time,this.heads.reduce(on,0))+1;this._clock=new w(this.clock.id,n);const o=Object.values(this.traverse(this.heads,Math.max(t,this.heads.length))),i=(e=>{const t=new Set;for(let r=1;r<=e;r*=2){const e=Math.min(r-1,o.length-1);t.add(o[e])}return t})(Math.min(t,o.length));o.length<t&&o[o.length-1]&&i.add(o[o.length-1]);const s=Object.keys(this.heads.reverse().reduce(sn,{})),a=Array.from(i).map(tn).filter((e=>!s.includes(e))),c=await Nr.create(this._storage,this._identity,this.id,e,s,this.clock,a,r);if(!await this._access.canAppend(c,this._identity.provider))throw new Error(`Could not append entry, key "${this._identity.id}" is not allowed to write to the log`);return this._entryIndex.set(c.hash,c),s.forEach((e=>this._nextsIndex[e]=c.hash)),this._headsIndex={},this._headsIndex[c.hash]=c,this._length++,c}iterator({gt:e,gte:t,lt:r,lte:n,amount:o=-1}={}){if(0===o)return function*(){}();if("string"==typeof n&&(n=[this.get(n)]),"string"==typeof r&&(r=[this.get(this.get(r).next[0])]),n&&!Array.isArray(n))throw zr();if(r&&!Array.isArray(r))throw zr();const i=(n||r||this.heads).filter(vr),s=t?this.get(t).hash:e?this.get(e).hash:null,a=s?-1:o||-1,c=this.traverse(i,a,s);let u=Object.values(c);return e&&u.pop(),(e||t)&&o>-1&&(u=u.slice(u.length-o,u.length)),function*(){for(const e in u)yield u[e]}()}async join(e,t=-1){if(!vr(e))throw Lr();if(!an.isLog(e))throw Mr();if(this.id!==e.id)return;const r=an.difference(e,this),n=this._identity.provider,o=async e=>{if(!await this._access.canAppend(e,n))throw new Error(`Could not append entry, key "${e.identity.id}" is not allowed to write to the log`)},i=Object.values(r);await f(i,(async e=>{await o(e),await(async e=>{const t=await Nr.verify(n,e),r=e.identity?e.identity.publicKey:e.key;if(!t)throw new Error(`Could not validate signature "${e.sig}" for entry "${e.hash}" and key "${r}"`)})(e)}),{concurrency:this.joinConcurrency}),Object.values(r).forEach((e=>{this.get(e.hash)||this._length++,e.next.forEach((t=>this._nextsIndex[t]=e.hash))})),this._entryIndex.add(r);const s=Object.values(r).map(nn).reduce(rn,[]),a=an.findHeads(Object.values(Object.assign({},this._headsIndex,e._headsIndex))).filter((e=>!s.find((t=>t===e.hash)))).filter((e=>!this._nextsIndex[e.hash])).reduce(sn,{});if(this._headsIndex=a,t>-1){let e=this.values;e=e.slice(-t),this._entryIndex=null,this._entryIndex=new Yr(e.reduce(sn,{})),this._headsIndex=an.findHeads(e).reduce(sn,{}),this._length=this._entryIndex.length}const c=Object.values(this._headsIndex).reduce(on,0);return this._clock=new w(this.clock.id,Math.max(this.clock.time,c)),this}toJSON(){return{id:this.id,heads:this.heads.sort(this._sortFn).reverse().map(tn)}}toSnapshot(){return{id:this.id,heads:this.heads,values:this.values}}toBuffer(){return Buffer.from(JSON.stringify(this.toJSON()))}toString(e){return this.values.slice().reverse().map(((t,r)=>{const n=Nr.findChildren(t,this.values).length;let o=new Array(Math.max(n-1,0));return o=n>1?o.fill("  "):o,o=n>0?o.concat(["└─"]):o,o.join("")+(e?e(t.payload):t.payload)})).join("\n")}static isLog(e){return void 0!==e.id&&void 0!==e.heads&&void 0!==e._entryIndex}toMultihash({format:e}={}){return Qr.toMultihash(this._storage,this,{format:e})}static async fromMultihash(e,t,r,{access:n,length:o=-1,exclude:i=[],shouldExclude:s,timeout:a,concurrency:c,sortFn:u,onProgressCallback:h}={}){const{logId:l,entries:f,heads:d}=await Qr.fromMultihash(e,r,{length:o,exclude:i,shouldExclude:s,timeout:a,onProgressCallback:h,concurrency:c,sortFn:u});return new an(e,t,{logId:l,access:n,entries:f,heads:d,sortFn:u})}static async fromEntryHash(e,t,r,{logId:n,access:o,length:i=-1,exclude:s=[],shouldExclude:a,timeout:c,concurrency:u,sortFn:h,onProgressCallback:l}={}){const{entries:f}=await Qr.fromEntryHash(e,r,{length:i,exclude:s,shouldExclude:a,timeout:c,concurrency:u,onProgressCallback:l});return new an(e,t,{logId:n,access:o,entries:f,sortFn:h})}static async fromJSON(e,t,r,{access:n,length:o=-1,timeout:i,sortFn:s,onProgressCallback:a}={}){const{logId:c,entries:u}=await Qr.fromJSON(e,r,{length:o,timeout:i,onProgressCallback:a});return new an(e,t,{logId:c,access:n,entries:u,sortFn:s})}static async fromEntry(e,t,r,{access:n,length:o=-1,exclude:i=[],timeout:s,concurrency:a,sortFn:c,onProgressCallback:u}={}){const{logId:h,entries:l}=await Qr.fromEntry(e,r,{length:o,exclude:i,timeout:s,concurrency:a,onProgressCallback:u});return new an(e,t,{logId:h,access:n,entries:l,sortFn:c})}static findHeads(e){const t=e.reduce(((e,t,r,n)=>(t.next.forEach((r=>e[r]=t.hash)),e)),{});return e.filter((e=>void 0===t[e.hash])).sort(((e,t)=>e.clock.id>t.clock.id))}static findTails(e){const t={},r=[],n={};let o=[];e.forEach((e=>{0===e.next.length&&r.push(e),e.next.forEach((r=>{t[r]||(t[r]=[]),t[r].push(e)})),o=o.concat(e.next),n[e.hash]=!0}));const i=o.filter((e=>void 0===n[e])).map((e=>t[e])).reduce(((e,t,r,n)=>e.concat(Hr(t,"hash"))),[]).concat(r);return Hr(i,"hash").sort(Nr.compare)}static findTailHashes(e){const t={};return e.forEach((e=>t[e.hash]=!0)),e.reduce(((e,r,n,o)=>(r.next.reverse().forEach((r=>{void 0===t[r]&&e.splice(0,0,r)})),e)),[])}static difference(e,t){const r=Object.keys(e._headsIndex),n={},o={},i=e=>{n[e]||t.get(e)||(r.push(e),n[e]=!0)};for(;r.length>0;){const s=r.shift(),a=e.get(s);a&&!t.get(s)&&a.id===t.id&&(o[a.hash]=a,n[a.hash]=!0,a.next.concat(a.refs).forEach(i))}return o}}const cn=an})(),Log=n})();