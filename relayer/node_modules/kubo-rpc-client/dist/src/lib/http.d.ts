/// <reference types="node" />
import { URLSearchParams } from 'iso-url';
import { TimeoutError, HTTPError } from './http/error.js';
import type { UploadProgressFn } from '../index.js';
type Override<T, R> = Omit<T, keyof R> & R;
export type FetchOptions = Override<RequestInit, {
    /**
     * Amount of time until request should timeout in ms.
     */
    timeout?: number | string;
    /**
     * URL search param.
     */
    searchParams?: URLSearchParams;
    /**
     * Can be passed to track upload progress.
     * Note that if this option in passed underlying request will be performed using `XMLHttpRequest` and response will not be streamed.
     */
    onUploadProgress?: UploadProgressFn;
    /**
     * Can be passed to track download progress.
     */
    onDownloadProgress?: UploadProgressFn;
    overrideMimeType?: string;
}>;
export interface HTTPOptions extends FetchOptions {
    json?: any;
    /**
     * The base URL to use in case url is a relative URL
     */
    base?: string;
    /**
     * Throw not ok responses as Errors
     */
    throwHttpErrors?: boolean;
    /**
     * Transform search params
     */
    transformSearchParams?(params: URLSearchParams): URLSearchParams;
    /**
     * When iterating the response body, transform each chunk with this function.
     */
    transform?(chunk: any): any;
    /**
     * Handle errors
     */
    handleError?(rsp: Response): Promise<void>;
    /**
     * Control request creation
     */
    agent?: any;
}
export interface ExtendedResponse extends Response {
    iterator(): AsyncGenerator<Uint8Array, void, undefined>;
    ndjson(): AsyncGenerator<any, void, undefined>;
}
export declare class HTTP {
    static HTTPError: typeof HTTPError;
    static TimeoutError: typeof TimeoutError;
    static post: (resource: string | Request, options?: HTTPOptions) => Promise<ExtendedResponse>;
    static get: (resource: string | Request, options?: HTTPOptions) => Promise<ExtendedResponse>;
    static put: (resource: string | Request, options?: HTTPOptions) => Promise<ExtendedResponse>;
    static delete: (resource: string | Request, options?: HTTPOptions) => Promise<ExtendedResponse>;
    static options: (resource: string | Request, options?: HTTPOptions) => Promise<ExtendedResponse>;
    readonly opts: HTTPOptions;
    constructor(options?: HTTPOptions);
    /**
     * Fetch
     */
    fetch(resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse>;
    post(resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse>;
    get(resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse>;
    put(resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse>;
    delete(resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse>;
    options(resource: string | Request, options?: HTTPOptions): Promise<ExtendedResponse>;
}
export {};
//# sourceMappingURL=http.d.ts.map