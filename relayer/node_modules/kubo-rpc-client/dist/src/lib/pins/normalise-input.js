import { CodeError } from '@libp2p/interface';
import { CID } from 'multiformats/cid';
function isIterable(thing) {
    return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
    return Symbol.asyncIterator in thing;
}
function isCID(thing) {
    return CID.asCID(thing) != null;
}
/**
 * Transform one of:
 *
 * ```ts
 * CID
 * String
 * { cid: CID recursive, metadata }
 * { path: String recursive, metadata }
 * Iterable<CID>
 * Iterable<String>
 * Iterable<{ cid: CID recursive, metadata }>
 * Iterable<{ path: String recursive, metadata }>
 * AsyncIterable<CID>
 * AsyncIterable<String>
 * AsyncIterable<{ cid: CID recursive, metadata }>
 * AsyncIterable<{ path: String recursive, metadata }>
 * ```
 * Into:
 *
 * ```ts
 * AsyncIterable<{ path: CID|String, recursive:boolean, metadata }>
 * ```
 */
// eslint-disable-next-line complexity
export async function* normaliseInput(input) {
    // must give us something
    if (input === null || input === undefined) {
        throw new CodeError(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT');
    }
    // CID
    const cid = CID.asCID(input);
    if (cid != null) {
        yield toPin({ cid });
        return;
    }
    if (typeof input === 'string') {
        yield toPin({ path: input });
        return;
    }
    // { cid: CID recursive, metadata }
    // @ts-expect-error - it still could be iterable or async iterable
    if (input.cid != null || input.path != null) {
        // @ts-expect-error cannot derive type
        return yield toPin(input);
    }
    // Iterable<?>
    if (isIterable(input)) {
        const iterator = input[Symbol.iterator]();
        const first = iterator.next();
        if (first.done === true) {
            return iterator;
        }
        // Iterable<CID>
        if (isCID(first.value)) {
            yield toPin({ cid: first.value });
            for (const cid of iterator) {
                yield toPin({ cid });
            }
            return;
        }
        // Iterable<String>
        if (typeof first.value === 'string') {
            yield toPin({ path: first.value });
            for (const path of iterator) {
                yield toPin({ path });
            }
            return;
        }
        // Iterable<Pinnable>
        if (first.value.cid != null || first.value.path != null) {
            yield toPin(first.value);
            for (const obj of iterator) {
                yield toPin(obj);
            }
            return;
        }
        throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT');
    }
    // AsyncIterable<?>
    if (isAsyncIterable(input)) {
        const iterator = input[Symbol.asyncIterator]();
        const first = await iterator.next();
        if (first.done === true)
            return iterator;
        // AsyncIterable<CID>
        if (isCID(first.value)) {
            yield toPin({ cid: first.value });
            for await (const cid of iterator) {
                yield toPin({ cid });
            }
            return;
        }
        // AsyncIterable<String>
        if (typeof first.value === 'string') {
            yield toPin({ path: first.value });
            for await (const path of iterator) {
                yield toPin({ path });
            }
            return;
        }
        // AsyncIterable<{ cid: CID|String recursive, metadata }>
        if (first.value.cid != null || first.value.path != null) {
            yield toPin(first.value);
            for await (const obj of iterator) {
                yield toPin(obj);
            }
            return;
        }
        throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT');
    }
    throw new CodeError(`Unexpected input: ${typeof input}`, 'ERR_UNEXPECTED_INPUT');
}
function toPin(input) {
    const path = input.cid ?? `${input.path}`;
    if (path == null) {
        throw new CodeError('Unexpected input: Please path either a CID or an IPFS path', 'ERR_UNEXPECTED_INPUT');
    }
    const pin = {
        path,
        recursive: input.recursive !== false
    };
    if (input.metadata != null) {
        pin.metadata = input.metadata;
    }
    return pin;
}
//# sourceMappingURL=normalise-input.js.map