const LOAD_BASE = async (name) => Promise.reject(new Error(`No base found for "${name}"`));
export class Multibases {
    _basesByName;
    _basesByPrefix;
    _loadBase;
    constructor(options) {
        // Object with current list of active resolvers
        this._basesByName = {};
        // Object with current list of active resolvers
        this._basesByPrefix = {};
        this._loadBase = options.loadBase ?? LOAD_BASE;
        // Enable all supplied codecs
        for (const base of options.bases) {
            this.addBase(base);
        }
    }
    /**
     * Add support for a multibase codec
     */
    addBase(base) {
        if (this._basesByName[base.name] != null && this._basesByPrefix[base.prefix] != null) {
            throw new Error(`Codec already exists for codec "${base.name}"`);
        }
        this._basesByName[base.name] = base;
        this._basesByPrefix[base.prefix] = base;
    }
    /**
     * Remove support for a multibase codec
     */
    removeBase(base) {
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete this._basesByName[base.name];
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete this._basesByPrefix[base.prefix];
    }
    async getBase(nameOrPrefix) {
        if (this._basesByName[nameOrPrefix] != null) {
            return this._basesByName[nameOrPrefix];
        }
        if (this._basesByPrefix[nameOrPrefix] != null) {
            return this._basesByPrefix[nameOrPrefix];
        }
        // If not supported, attempt to dynamically load this codec
        const base = await this._loadBase(nameOrPrefix);
        if (this._basesByName[base.name] == null && this._basesByPrefix[base.prefix] == null) {
            this.addBase(base);
        }
        return base;
    }
    listBases() {
        return Object.values(this._basesByName);
    }
}
//# sourceMappingURL=multibases.js.map